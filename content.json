[{"title":"SpringMVC入门篇(2)","date":"2018-05-16T09:13:18.622Z","path":"/posts/56977/","text":"SpringMVC入门篇(二)参数绑定默认支持的参数类型处理器形参中添加如下类型的参数处理适配器会默认识别并进行赋值。 HttpServletRequest 通过request对象获取请求信息 HttpServletResponse 通过response处理响应信息 HttpSession 通过session对象得到session中存放的对象 Model/ModelMap 除了ModelAndView以外，还可以使用Model来向页面传递数据， Model是一个接口，在参数里直接声明model即可 绑定简单类型当请求的参数名称和处理器形参名称一致时会将请求参数与形参进行绑定。这样，从Request取参数的方法就可以进一步简化 举例:12345678@RequestMapping(\"/itemEdit\")public String queryItemById(int id, ModelMap model) &#123; // 根据id查询商品数据 Item item = this.itemService.queryItemById(id); // 把商品数据放在模型中 model.addAttribute(\"item\", item); return \"itemEdit\";&#125; 支持的数据类型 参数类型推荐使用包装数据类型，因为基础数据类型不可以为null @RequestParam 使用@RequestParam常用于处理简单类型的绑定 value:参数名字，即入参的请求参数名字，如value=“itemId”表示请求的参数, 区中的名字为itemId的参数的值将传入 required:是否必须，默认是true，表示请求中一定要有相应的参数，否则将报错 defaultValue:默认值，表示如果请求中没有同名参数时的默认值 123456789public String queryItemById(@RequestParam(value = \"itemId\", required = true, defaultValue = \"1\") Integer id,ModelMap modelMap) &#123; // 根据id查询商品数据 Item item = this.itemService.queryItemById(id); // 把商品数据放在模型中 modelMap.addAttribute(\"item\", item); return \"itemEdit\";&#125; 绑定pojo类型如果提交的参数很多，或者提交的表单中的内容很多的时候,可以使用简单类型接受数据,也可以使用pojo接收数据 要求：pojo对象中的属性名和表单中input的name属性一致。 1234567@RequestMapping(\"/updateItem\")public String updateItem(Item item) &#123; // 调用服务更新商品 this.itemService.updateItemById(item); // 返回逻辑视图 return \"success\";&#125; 绑定包装pojo包装pojo的定义 1234public class QueryVo &#123; private Item item; set/get。。。&#125; 绑定包装pojo 1234567// 绑定包装数据类型@RequestMapping(\"/queryItem\")public String queryItem(QueryVo queryVo) &#123; System.out.println(queryVo.getItem().getId()); System.out.println(queryVo.getItem().getName()); return \"success\";&#125; 自定义参数绑定由于日期数据有很多种格式，springmvc没办法把字符串转换成日期类型。所以需要自定义参数绑定。 前端控制器接收到请求后，找到注解形式的处理器适配器，对RequestMapping标记的方法进行适配，并对方法中的形参进行参数绑定。可以在springmvc处理器适配器上自定义转换器Converter进行参数绑定。 自定义Converter12345678910111213141516171819//Converter&lt;S, T&gt;//S:source,需要转换的源的类型//T:target,需要转换的目标类型public class DateConverter implements Converter&lt;String, Date&gt; &#123; @Override public Date convert(String source) &#123; try &#123; // 把字符串转换为日期类型 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(\"yyy-MM-dd HH:mm:ss\"); Date date = simpleDateFormat.parse(source); return date; &#125; catch (ParseException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; // 如果转换异常则返回空 return null; &#125;&#125; 配置Converter1234567891011&lt;!-- 配置注解驱动 --&gt;&lt;mvc:annotation-driven conversion-service=\"conversionService\" /&gt;&lt;!-- 转换器配置 --&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.format.support.FormattingConversionServiceFactoryBean\"&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;bean class=\" club.ellisl.ssm.converter.DateConverter\" /&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt; 高级参数绑定绑定数组 需求: 在商品列表页面选中多个商品，然后删除。 Controller方法中可以用String[]接收，或者pojo的String[]属性接收。两种方式任选其一即可。 ItemController类 1234567891011121314/** * 包装类型 绑定数组类型，可以使用两种方式，pojo的属性接收，和直接接收 * * @param queryVo * @return */@RequestMapping(\"queryItem\")public String queryItem(QueryVo queryVo, Integer[] ids) &#123; System.out.println(queryVo.getItem().getId()); System.out.println(queryVo.getItem().getName()); System.out.println(queryVo.getIds().length); System.out.println(ids.length); return \"success\";&#125; 将表单的数据绑定到ListList中存放对象，并将定义的List放在包装类QueryVo中使用包装pojo对象接收 jsp页面改造: 123456789101112131415&lt;c:forEach items=\"$&#123;itemList &#125;\" var=\"item\" varStatus=\"s\"&gt;&lt;tr&gt; &lt;td&gt;&lt;input type=\"checkbox\" name=\"ids\" value=\"$&#123;item.id&#125;\"/&gt;&lt;/td&gt; &lt;td&gt; &lt;input type=\"hidden\" name=\"itemList[$&#123;s.index&#125;].id\" value=\"$&#123;item.id &#125;\"/&gt; &lt;input type=\"text\" name=\"itemList[$&#123;s.index&#125;].name\" value=\"$&#123;item.name &#125;\"/&gt; &lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"itemList[$&#123;s.index&#125;].price\" value=\"$&#123;item.price &#125;\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"itemList[$&#123;s.index&#125;].createtime\" value=\"&lt;fmt:formatDate value=\"$&#123;item.createtime&#125;\" pattern=\"yyyy-MM-dd HH:mm:ss\"/&gt;\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;input type=\"text\" name=\"itemList[$&#123;s.index&#125;].detail\" value=\"$&#123;item.detail &#125;\"/&gt;&lt;/td&gt; &lt;td&gt;&lt;a href=\"$&#123;pageContext.request.contextPath &#125;/itemEdit.action?id=$&#123;item.id&#125;\"&gt;修改&lt;/a&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/c:forEach&gt; ${current} 当前这次迭代的（集合中的）项 ${status.first} 判断当前项是否为集合中的第一项，返回值为true或false ${status.last} 判断当前项是否为集合中的最后一项 varStatus属性常用参数总结下： ${status.index} 输出行号，从0开始。 ${status.count} 输出行号，从1开始。 ${status.后一项，返回值为true或false begin、end、step分别表示：起始序号，结束序号，跳跃步伐。 注意：接收List类型的数据必须是pojo的属性，如果方法的形参为ArrayList类型无法正确接收到数据。 @RequestMapping注解通过@RequestMapping注解可以定义不同的处理器映射规则 将注解添加在类上面在class上添加@RequestMapping(url)指定通用请求前缀， 限制此类下的所有方法请求url必须以请求前缀开头 此时需要进入queryItemList()方法的请求url为： http://127.0.0.1:8080/springmvc-web2/item/itemList.action http://127.0.0.1:8080/springmvc-web2/item/itemListAll.action 请求方法限定限定GET方法 @RequestMapping(method = RequestMethod.GET) 限定POST方法 @RequestMapping(method = RequestMethod.POST) Controller方法返回值1.返回ModelAndViewcontroller方法中定义ModelAndView对象并返回，对象中可添加model数据、指定view。 2.返回void在Controller方法形参上可以定义request和response，使用request或response指定响应结果： 1、使用request转发页面，如下： request.getRequestDispatcher(“页面路径”).forward(request, response); 1request.getRequestDispatcher(\"/WEB-INF/jsp/success.jsp\").forward(request, response); 2、可以通过response页面重定向： response.sendRedirect(“url”) 1response.sendRedirect(\"/springmvc-web2/itemEdit.action\"); 3、可以通过response指定响应结果，例如响应json数据如下： 1response.getWriter().print(\"&#123;\\\"abc\\\":123&#125;\"); 3.返回字符串 逻辑视图名 controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。 12//指定逻辑视图名，经过视图解析器解析为jsp物理路径：/WEB-INF/jsp/itemList.jspreturn \"itemList\"; 2.Redirect重定向 Contrller方法返回字符串可以重定向到一个url地址 12345678910RequestMapping(\"updateItem\")public String updateItemById(Item item) &#123; // 更新商品 this.itemService.updateItemById(item) // 修改商品成功后，重定向到商品编辑页面 // 重定向后浏览器地址栏变更为重定向的地址， // 重定向相当于执行了新的request和response，所以之前的请求参数都会丢失 // 如果要指定请求参数，需要在重定向的url后面添加 ?itemId=1 这样的请求参数 return \"redirect:/itemEdit.action?itemId=\" + item.getId();&#125; 3.forward转发 Controller方法执行后继续执行另一个Controller方法 1234567891011121314@RequestMapping(\"updateItem\")public String updateItemById(Item item) &#123; // 更新商品 this.itemService.updateItemById(item); // 修改商品成功后，重定向到商品编辑页面 // 重定向后浏览器地址栏变更为重定向的地址， // 重定向相当于执行了新的request和response，所以之前的请求参数都会丢失 // 如果要指定请求参数，需要在重定向的url后面添加 ?itemId=1 这样的请求参数 // return \"redirect:/itemEdit.action?itemId=\" + item.getId(); // 修改商品成功后，继续执行另一个方法 // 使用转发的方式实现。转发后浏览器地址栏还是原来的请求地址， // 转发并没有执行新的request和response，所以之前的请求参数都存在 return \"forward:/itemEdit.action\";&#125; 异常处理器自定义异常类12345678910111213141516171819202122public class MyException extends Exception &#123; // 异常信息 private String message; public MyException() &#123; super(); &#125; public MyException(String message) &#123; super(); this.message = message; &#125; public String getMessage() &#123; return message; &#125; public void setMessage(String message) &#123; this.message = message; &#125;&#125; 自定义异常处理器12345678910111213141516171819202122232425public class CustomHandleException implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(HttpServletRequest request, HttpServletResponse response, Object handler, Exception exception) &#123; // 定义异常信息 String msg; // 判断异常类型 if (exception instanceof MyException) &#123; // 如果是自定义异常，读取异常信息 msg = exception.getMessage(); &#125; else &#123; // 如果是运行时异常，则取错误堆栈，从堆栈中获取异常信息 Writer out = new StringWriter(); PrintWriter s = new PrintWriter(out); exception.printStackTrace(s); msg = out.toString(); &#125; // 把错误信息发给相关人员,邮件,短信等方式 // 返回错误页面，给用户友好页面显示错误信息 ModelAndView modelAndView = new ModelAndView(); modelAndView.addObject(\"msg\", msg); modelAndView.setViewName(\"error\"); return modelAndView; &#125;&#125; 异常处理器配置在springmvc.xml中添加： 123&lt;!-- 配置全局异常处理器 --&gt;&lt;bean id=\"customHandleException\" class=\"club.ellisl.ssm.exception.CustomHandleException\"/&gt;","tags":[{"name":"SSM","slug":"SSM","permalink":"http://ellisl.club/tags/SSM/"}]},{"title":"Zookeeper","date":"2018-05-16T07:28:31.000Z","path":"/posts/11921/","text":"Zookeeper简述 Zookeeper是Apache Hadoop的一个子项目，作为分布式协调作用（类似于我们的大脑），树形的目录结构，支持变更操作，同时也是Dubbo官方推荐的注册中心。 Zookeeper之所以能用来作为dubbo的注册中心来使用，主要是应用到dubbo的命名功能.在SOA架构、集群和分布式环境下，子项目之间的调用关系会变得越来越复杂，因为需要一个服务器专门给我们管理服务的信息和调节、管理这些服务，让我们的侧重点放在项目中的业务上，因为zookeeper的命名功能就可以充当这样一个服务器。 Zookeeper的实现原理Zookeeper会维护一个类似于标准的文件系统的具有层次关系的数据结构。这个文件系统中每个子目录项都被称为znode节点，这个znode节点也可以有子节点，每个节点都可以存储数据，客户端也可以对这些node节点进行getChildren，getData,exists方法，同时也可以在znode tree路径上设置watch（类似于监听），当watch路径上发生节点create、delete、update的时候，会通知到client。client可以得到通知后，再获取数据，执行业务逻辑操作。Zookeeper 的作用主要是用来维护和监控存储的node节点上这些数据的状态变化，通过监控这些数据状态的变化，从而达到基于数据的集群管理。 为什么要用Zookeeper作为注册服务中心?Zookeeper的数据模型是由一系列的Znode数据节点组成，和文件系统类似。但是与传统的磁盘文件系统不同的是，首先，zookeeper的数据全部存储在内存中，性能高；其次，zookeeper也支持集群，实现了高可用；同时基于zookeeper的特性,也支持事件监听（服务的暴露方发生变化，可以进行推送），因为zookeeper适合作为dubbo的注册中心区使用。 同时redis、Simple也可以作为dubbo的注册中心来使用。 redis: Redis:用key-value（Hash）来存储数据 主key:服务器名和类型 Map中的key：url地址 Map中的value：过期时间，判断脏数据，脏数据由监控中心删除（要求服务器时间必须相同） 利用redis中的Publish/Subscribe事件通知数据变更 总之，redis作为注册中心来使用的话，支持集群，性能高，但是要求所有服务器的时间必须同步，要求较高。（redis作为注册中心来使用，有的公司也在采用）Simple: 本身就是一个普通的dubbo服务，能减少第三方依赖，不支持集群，不适合生产环境。 在linux系统上配置Zookeeper","tags":[{"name":"分布式","slug":"分布式","permalink":"http://ellisl.club/tags/分布式/"}]},{"title":"SpringMVC入门篇(1)","date":"2018-05-16T07:28:31.000Z","path":"/posts/4780/","text":"SpringMVC入门篇(一)Spring MVC概述：Spring MVC是Spring提供的一个强大而灵活的web框架。借助于注解，Spring MVC提供了几乎是POJO的开发模式，使得控制器的开发和测试更加简单。这些控制器一般不直接处理请求，而是将其委托给Spring上下文中的其他bean，通过Spring的依赖注入功能，这些bean被注入到控制器中。 Spring MVC主要由DispatcherServlet、处理器映射、处理器(控制器)、视图解析器、视图组成。他的两个核心是： 处理器映射：选择使用哪个控制器来处理请求 视图解析器：选择结果应该如何渲染 通过以上两点，Spring MVC保证了如何选择控制处理请求和如何选择视图展现输出之间的松耦合。 Spring的处理流程原理 Spring架构 框架流程 用户发送请求至前端控制器DispatcherServlet DispatcherServlet收到请求调用HandlerMapping处理器映射器。 处理器映射器根据请求url找到具体的处理器，生成处理器对象及处理器拦截器(如果有则生成)一并返回给DispatcherServlet。 DispatcherServlet通过HandlerAdapter处理器适配器调用处理器 执行处理器(Controller，也叫后端控制器) Controller执行完成返回ModelAndView HandlerAdapter将controller执行结果ModelAndView返回给DispatcherServlet DispatcherServlet将ModelAndView传给ViewReslover视图解析器 ViewReslover解析后返回具体View DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。 DispatcherServlet响应用户 SpringMVC组件说明DispatcherServlet: 前端控制器用户请求到达前端控制器，它就相当于mvc模式中的c， dispatcherServlet是整个流程控制的中心， 由它调用其它组件处理用户的请求， dispatcherServlet的存在降低了组件之间的耦合性。 HandlerMapping：处理器映射器HandlerMapping负责根据用户请求url找到Handler即处理器， springmvc提供了不同的映射器实现不同的映射方式， 例如：配置文件方式，实现接口方式，注解方式等。 HandlAdapter：处理器适配器通过HandlerAdapter对处理器进行执行，这是适配器模式的应用， 通过扩展适配器可以对更多类型的处理器进行执行。 ViewResolver：视图解析器View Resolver负责将处理结果生成View视图， View Resolver首先根据逻辑视图名解析成物理视图名 即具体的页面地址，再生成View视图对象， 最后对View进行渲染将处理结果通过页面展示给用户。 Handler：处理器Handler 是继DispatcherServlet前端控制器的后端控制器， 在DispatcherServlet的控制下Handler对具体的用户请求进行处理。 View：视图springmvc框架提供了很多的View视图类型的支持， 包括：jstlView、freemarkerView、pdfView等。 我们最常用的视图就是jsp。 说明: 在springmvc的各个组件中，处理器映射器、处理器适配器、视图解析器称为springmvc的三大组件。 需要用户开发的组件有 handler、view 配置文件的配置讲到配置文件,有三点需要配置: 配置controller扫描包使用context:component-scan自动扫描标记@Controller的控制器类 12&lt;!-- 配置controller扫描包，多个包之间用,分隔 --&gt;&lt;context:component-scan base-package=\"club.ellisl.springmvc.controller\" /&gt; 注解映射器和适配器配置处理器映射器注解式处理器映射器，对类中标记了@ResquestMapping的方法进行映射。根据@ResquestMapping定义的url匹配@ResquestMapping标记的方法，匹配成功返回HandlerMethod对象给前端控制器。 从spring3.1版本开始， 废除了DefaultAnnotationHandlerMapping的使用， 推荐使用RequestMappingHandlerMapping 完成注解式处理器映射。 123&lt;!-- 配置处理器映射器 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping\" /&gt; @RequestMapping:定义请求url到处理器功能方法的映射 配置处理器适配器注解式处理器适配器，对标记@ResquestMapping的方法进行适配。 从spring3.1版本开始， 废除了AnnotationMethodHandlerAdapter的使用， 推荐使用RequestMappingHandlerAdapter 完成注解式处理器适配 123&lt;!-- 配置处理器适配器 --&gt;&lt;bean class=\"org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerAdapter\" /&gt; 注解驱动直接配置处理器映射器和处理器适配器比较麻烦，可以使用注解驱动来加载 可以在springmvc.xml配置文件中使用该注解替代注解处理器和适配器的配置。 12&lt;!-- 注解驱动 --&gt;&lt;mvc:annotation-driven /&gt; 视图解析器视图解析器使用SpringMVC框架默认的InternalResourceViewResolver，这个视图解析器支持JSP视图解析 在springmvc.xml配置文件中配置如下： 12345678&lt;!-- 配置视图解析器 --&gt;&lt;bean class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;!-- 配置逻辑视图的前缀 --&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/jsp/\" /&gt; &lt;!-- 配置逻辑视图的后缀 --&gt; &lt;property name=\"suffix\" value=\".jsp\" /&gt;&lt;/bean&gt; 逻辑视图名需要在Controller中返回ModelAndView指定， 比如逻辑视图名为itemList，则最终返回的jsp视图地址: WEB-INF/jsp/itemList.jsp 最终jsp物理地址：前缀+逻辑视图名+后缀","tags":[{"name":"SSM","slug":"SSM","permalink":"http://ellisl.club/tags/SSM/"}]},{"title":"Mybatis入门和配置","date":"2018-05-15T11:50:48.000Z","path":"/posts/13919/","text":"Mybatis介绍 MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码 Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回 Mybatis解决jdbc编程的问题 数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。如果使用数据库连接池可解决此问题。 解决：在SqlMapConfig.xml中配置数据连接池，使用连接池管理数据库链接。 Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码。 解决：将Sql语句配置在XXXmapper.xml文件中与java代码分离。 使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。 解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。 对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。 解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。’ SqlMapConfig.xml—–&gt; Mybatis核心配置文件配置 头文件: 123&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; Mapper.xml—–&gt; sql映射文件的配置 头文件: 123&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; 映射配置:12345678910111213141516&lt;!-- namespace：命名空间，用于隔离sql --&gt;&lt;mapper namespace=\"user\"&gt; &lt;!-- id:statement的id 或者叫做sql的id--&gt; &lt;!-- parameterType:声明输入参数的类型 --&gt; &lt;!-- resultType:声明输出结果的类型，应该填写pojo的全路径 --&gt; !-- #&#123;&#125;：输入参数的占位符，相当于jdbc的？ --&gt; &lt;select id=\"queryUserById\" parameterType=\"int\" resultType=\"cn.itcast.mybatis.pojo.User\"&gt; SELECT * FROM `user` WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 如果传入的参数是简单数据类型，$&#123;&#125;里面必须写value --&gt; &lt;select id=\"queryUserByUsername2\" parameterType=\"string\" resultType=\"cn.itcast.mybatis.pojo.User\"&gt; SELECT * FROM `user` WHERE username LIKE '%$&#123;value&#125;%' &lt;/select&gt;&lt;/mapper&gt; 小结${}和#{}的使用 #{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值,自动进行java类型和jdbc类型转换。#{}可以有效防止sql注入。#{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。 ${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。值得注意的是 该方式不能有效的防止sql注入 parameterType和resultType parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。 resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。如果有多条数据，则分别进行映射，并把对象放到容器List中 selectOne和selectList selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常 org.apache.ibatis.exceptions.TooManyResultsException selectList可以查询一条或多条记录。 Mysql自增主键返回 在新增记录的时候在sql语句之前配置主键自增 1234567&lt;!-- order：设置在执行insert语句前执行查询id的sql，还指在执行insert语句之后执行查询id的sql --&gt;&lt;!-- resultType：设置返回的id的类型 --&gt;&lt;selectKey keyColumn=\"id\" keyProperty=\"id\" order=\"AFTER\" resultType=\"int\"&gt; SELECT LAST_INSERT_ID()&lt;/selectKey&gt; uuid实现主键 123&lt;selectKey keyColumn=\"id\" keyProperty=\"id\" order=\"BEFORE\" resultType=\"string\"&gt; SELECT LAST_INSERT_ID()&lt;/selectKey&gt; SqlSession的使用范围了解SqlSession的使用范围,首先要明白他是怎么创建的 SqlSession中封装了对数据库的操作，如：查询、插入、更新、删除等。 SqlSession通过SqlSessionFactory创建。 SqlSessionFactory是通过SqlSessionFactoryBuilder进行创建。 1.SqlSessionFactoryBuilder SqlSessionFactoryBuilder用于创建SqlSessionFacoty， SqlSessionFacoty一旦创建完成就不需要SqlSessionFactoryBuilder了， 因为SqlSession是通过SqlSessionFactory创建的。 所以可以将SqlSessionFactoryBuilder当成一个工具类使用， 最佳使用范围是方法范围即方法体内局部变量。 2.SqlSessionFactory SqlSessionFactory是一个接口，接口中定义了openSession的不同重载方法， SqlSessionFactory的最佳使用范围是整个应用运行期间，一旦创建后可以重复使用， 通常以单例模式管理SqlSessionFactory。 3.SqlSession SqlSession是一个面向用户的接口，sqlSession中定义了数据库操作方法。 每个线程都应该有它自己的SqlSession实例。 SqlSession的实例不能共享使用，它也是线程不安全的。 因此最佳的范围是请求或方法范围。 绝对不能将SqlSession实例的引用放在一个类的静态字段或实例字段中。 打开一个 SqlSession；使用完毕就要关闭它。 Mapper动态代理方式Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper接口开发需要遵循以下规范：Mapper.xml文件中的namespace与mapper接口的类路径相同。 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 Mapper.xml(映射文件)的配置12345&lt;mapper namespace=\"Mapper接口类路径\"&gt; &lt;select id=\"Mapper接口方法名\" parameterType=\"接口方法参数类型\" resultType=\"接口方法返回值类型\"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 注意:要在Mabits核心配置文件中配置加载映射文件(Mapper.xml) SqlMapConfig.xml配置文件的其他配置properties（属性）1234567&lt;!-- 使用resource属性加载外部配置文件 --&gt;&lt;properties resource=\"db.properties\"&gt; &lt;!-- 在properties内部用property定义属性 --&gt; &lt;!-- 如果外部配置文件有该属性，则内部定义属性被外部属性覆盖 --&gt; &lt;property name=\"jdbc.username\" value=\"root123\" /&gt; &lt;property name=\"jdbc.password\" value=\"root123\" /&gt;&lt;/properties&gt; typeAliases（类型别名）在Mybatis中有一些默认的别名,例如返回值类型的配置的时候,直接写类型名即可,不需要写类型的全限定名,这就是因为在Mybatis中已经配置好了一些默认的类型别名,直接使用即可,除此之外,还可以自定义类型别名: 在SqlMapConfig.xml中配置如下： 1234567&lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias=\"user\" type=\"User类的全限定名\" /&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（大小写不敏感） --&gt; &lt;package name=\"包扫描路径\" /&gt; &lt;package name=\"其它包\" /&gt;&lt;/typeAliases&gt; 需要注意的是,别名的大小写不敏感 mappers（映射器）Mapper配置的几种方法： 方式一: 12&lt;mapper resource=\" \" /&gt;&lt;!--使用相对于类路径的资源--&gt; 方式二: 12&lt;mapper class=\" \" /&gt;&lt;!--使用mapper接口类路径--&gt; 方式三:12&lt;package name=\"\"/&gt;&lt;!--注册指定包下的所有mapper接口--&gt; 注意: 使用方法二三时,要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中 动态sql通过mybatis提供的各种标签方法实现动态拼接sql 举例:需求是:根据姓名和性别查询用户,有可能是姓名性别都没选中,有可能只有一个姓名或只有一个性别,或两个条件都有 if标签的使用通过使用if标签可以实现判断各种查询情景 12345678910&lt;select id=\"queryUserByWhere\" parameterType=\"user\" resultType=\"user\"&gt; SELECT id, username, birthday, sex, address FROM `user` WHERE 1=1 &lt;if test=\"sex != null and sex != ''\"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username LIKE '%$&#123;username&#125;%' &lt;/if&gt;&lt;/select&gt; where标签的使用通过where标签可以对上面代码进行改造,将不用再写where和1=1的条件 123456789101112&lt;select id=\"queryUserByWhere\" parameterType=\"user\" resultType=\"user\"&gt; SELECT id, username, birthday, sex, address FROM `user`&lt;!-- where标签可以自动添加where，同时处理sql语句中第一个and关键字 --&gt; &lt;where&gt; &lt;if test=\"sex != null\"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username LIKE '%$&#123;username&#125;%' &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; sql片段通过sql标签可以实现将重复性的条件提取出来直接在sql中引入即可(include) 12345&lt;!-- 声明sql片段 --&gt;&lt;sql id=\"userFields\"&gt; id, username, birthday, sex, address&lt;/sql&gt;SELECT &lt;include refid=\"userFields\" /&gt; FROM `user` foreach标签123456789101112131415&lt;select id=\"queryUserByIds\" parameterType=\"queryVo\" resultType=\"user\"&gt; SELECT * FROM `user` &lt;where&gt; &lt;!-- foreach标签，进行遍历 --&gt; &lt;!-- collection：遍历的集合，这里是QueryVo的ids属性 --&gt; &lt;!-- item：遍历的项目，可以随便写，，但是和后面的#&#123;&#125;里面要一致 --&gt; &lt;!-- open：在前面添加的sql片段 --&gt; &lt;!-- close：在结尾处添加的sql片段 --&gt; &lt;!-- separator：指定遍历的元素之间使用的分隔符 --&gt; &lt;foreach collection=\"ids\" item=\"item\" open=\"id IN (\" close=\")\" separator=\",\"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 关联查询:一对一查询:需求：查询所有订单信息，关联查询下单用户信息 方式一: 使用resultType 改造订单pojo类，此pojo类中包括了订单信息和用户信息这样返回对象的时候，mybatis自动把用户信息也注入进来了 方式二:使用resultMap 定义专门的resultMap用于映射一对一查询结果。 Mapper.xml配置如下:1234567891011121314151617&lt;resultMap type=\"order\" id=\"orderUserResultMap\"&gt; &lt;id property=\"id\" column=\"id\" /&gt; &lt;result property=\"userId\" column=\"user_id\" /&gt; &lt;result property=\"number\" column=\"number\" /&gt; &lt;result property=\"createtime\" column=\"createtime\" /&gt; &lt;result property=\"note\" column=\"note\" /&gt; &lt;!-- association ：配置一对一属性 --&gt; &lt;!-- property:order里面的User属性名 --&gt; &lt;!-- javaType:属性类型 --&gt; &lt;association property=\"user\" javaType=\"user\"&gt; &lt;!-- id:声明主键，表示user_id是关联查询对象的唯一标识--&gt; &lt;id property=\"id\" column=\"user_id\" /&gt; &lt;result property=\"username\" column=\"username\" /&gt; &lt;result property=\"address\" column=\"address\" /&gt; &lt;/association&gt;&lt;/resultMap&gt; 一对多查询:需求:查询所有用户信息及用户关联的订单信息 查询方法:第一步,实体类中配置一对多关系属性 第二步,编写Mapper.xml 1234567891011121314151617181920&lt;resultMap type=\"user\" id=\"userOrderResultMap\"&gt; &lt;id property=\"id\" column=\"id\" /&gt; &lt;result property=\"username\" column=\"username\" /&gt; &lt;result property=\"birthday\" column=\"birthday\" /&gt; &lt;result property=\"sex\" column=\"sex\" /&gt; &lt;result property=\"address\" column=\"address\" /&gt; &lt;!-- 配置一对多的关系 --&gt; &lt;collection property=\"orders\" javaType=\"list\" ofType=\"order\"&gt; &lt;!-- 配置主键，是关联Order的唯一标识 --&gt; &lt;id property=\"id\" column=\"id\" /&gt; &lt;result property=\"number\" column=\"number\" /&gt; &lt;result property=\"createtime\" column=\"createtime\" /&gt; &lt;result property=\"note\" column=\"note\" /&gt; &lt;/collection&gt;&lt;/resultMap&gt; &lt;!--配置查询--&gt;&lt;select id=\"queryUserOrder\" resultMap=\"userOrderResultMap\"&gt; SELECT * FROM `user` u LEFT JOIN `order` o ON u.id = o.user_id&lt;/select&gt; 第三步,在UserMapper接口中定义查询方法 第四步,测试","tags":[{"name":"SSM","slug":"SSM","permalink":"http://ellisl.club/tags/SSM/"}]},{"title":"Hibernate知识小结","date":"2018-04-28T05:25:41.000Z","path":"/posts/25673/","text":"Hibernate 小结Hibernate简介:Hibernate是一个开放源码的对象关系映射框架,他对JDBC进行了轻量级的对象封装它将实体类和数据库建立映射关系,是一个全自动的ORM框架,是java持久层框架之一 Hibernate的优势:1.对JDBC进行了轻量级的对象封装,简化了DAO层繁琐的重复性代码,减少了内存消耗,加快了运行效率 2.Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现，简化了DAO层编码工作 3.Hibernate支持很多关系型数据库 4.开放源码,可扩展性强 ORM:对象关系映射:就是实体类和数据库表建立对应关系 通过Hibernate映射文件和Hibernate的核心配置文件实现 操作对象就相当于操作数据库表 执行原理: 1.get()在程序运行期间利用反射技术动态创建对象 2.根据hbm配置文件调用set方法进行绑定一一映射 实体类:1.实现序列化接口 2.私有化成员变量 3.提供无参构造(Hibernate反射创建对象用) 4.提供set/get方法 持久态对象的三种状态:1.瞬时态:不存在持久化标识OID 尚未与Hibernate Session关联对象,数据库中没有相应记录 2.持久态:存在持久化标识OID,与当前session有关联,并且关联的session没有关闭,数据库中有相应记录 3.托管态:存在持久化标识OID,与当前session没有关联,在数据库中有相应记录 Hibernate的一级缓存和二级缓存Hibernate向一级缓存存放数据时(保存在session中),同时保存快照数据(快照数据不可操作),当修改一级缓存中的数据进行flush操作时,会将session的数据和快照中的数据进行对比,若不一致,则会将session一级缓存中的数据更新到数据库中,同时更新快照区 get和load的区别:get如果没有找到会返回null,load如果没有找到会抛出异常 get会先查一级缓存,再查二级缓存,然后再查数据库 load会先查一级缓存,如果没找到就创建代理对象,等需要的时候去查询二级缓存和数据库(延迟加载) SessionFactory:SessionFactory是一个用于创建Session对象的工厂,是线程安全的,所以多个线程可以同时使用一个 SessionFactory.同时它里面还包含着对象关系映射有关的所以元数据,他是不可变的,一旦创建好就不能进行修改","tags":[{"name":"ssh","slug":"ssh","permalink":"http://ellisl.club/tags/ssh/"}]},{"title":"Dubbo分布式服务框架","date":"2017-08-20T05:06:24.000Z","path":"/posts/41159/","text":"基本概念Dubbo是一种分布式服务框架。 Webservice也是一种服务框架，但是webservice并不是分布式的服务框架，他需要结合F5实现负载均衡。因此，dubbo除了可以提供服务之外，还可以实现软负载均衡。它还提供了两个功能Monitor 监控中心和调用中心。 Dubbo架构 Dubbo架构 节点角色说明 节点角色说明 调用关系说明 服务容器负责启动，加载，运行服务提供者。 服务提供者在启动时，向注册中心注册自己提供的服务。 服务消费者在启动时，向注册中心订阅自己所需的服务。 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。 关于Dubbo架构的案例举例 架构举例","tags":[{"name":"分布式","slug":"分布式","permalink":"http://ellisl.club/tags/分布式/"}]}]