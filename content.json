[{"title":"Mybatis","date":"2018-05-15T11:50:48.000Z","path":"/posts/13919/","text":"Mybatis介绍 MyBatis是一个优秀的持久层框架，它对jdbc的操作数据库的过程进行封装，使开发者只需要关注 SQL 本身，而不需要花费精力去处理例如注册驱动、创建connection、创建statement、手动设置参数、结果集检索等jdbc繁杂的过程代码 Mybatis通过xml或注解的方式将要执行的各种statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过java对象和statement中的sql进行映射生成最终执行的sql语句，最后由mybatis框架执行sql并将结果映射成java对象并返回 Mybatis解决jdbc编程的问题 数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能。如果使用数据库连接池可解决此问题。 解决：在SqlMapConfig.xml中配置数据连接池，使用连接池管理数据库链接。 Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变java代码。 解决：将Sql语句配置在XXXmapper.xml文件中与java代码分离。 使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能多也可能少，修改sql还要修改代码，系统不易维护。 解决：Mybatis自动将java对象映射至sql语句，通过statement中的parameterType定义输入参数的类型。 对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库记录封装成pojo对象解析比较方便。 解决：Mybatis自动将sql执行结果映射至java对象，通过statement中的resultType定义输出结果的类型。’ SqlMapConfig.xml—–&gt; Mybatis核心配置文件配置 头文件: 123&lt;!DOCTYPE configurationPUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; Mapper.xml—–&gt; sql映射文件的配置 头文件: 123&lt;!DOCTYPE mapperPUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\"\"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; 映射配置:12345678910111213141516&lt;!-- namespace：命名空间，用于隔离sql --&gt;&lt;mapper namespace=\"user\"&gt; &lt;!-- id:statement的id 或者叫做sql的id--&gt; &lt;!-- parameterType:声明输入参数的类型 --&gt; &lt;!-- resultType:声明输出结果的类型，应该填写pojo的全路径 --&gt; !-- #&#123;&#125;：输入参数的占位符，相当于jdbc的？ --&gt; &lt;select id=\"queryUserById\" parameterType=\"int\" resultType=\"cn.itcast.mybatis.pojo.User\"&gt; SELECT * FROM `user` WHERE id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 如果传入的参数是简单数据类型，$&#123;&#125;里面必须写value --&gt; &lt;select id=\"queryUserByUsername2\" parameterType=\"string\" resultType=\"cn.itcast.mybatis.pojo.User\"&gt; SELECT * FROM `user` WHERE username LIKE '%$&#123;value&#125;%' &lt;/select&gt;&lt;/mapper&gt; 小结${}和#{}的使用 #{}表示一个占位符号，通过#{}可以实现preparedStatement向占位符中设置值,自动进行java类型和jdbc类型转换。#{}可以有效防止sql注入。#{}可以接收简单类型值或pojo属性值。 如果parameterType传输单个简单类型值，#{}括号中可以是value或其它名称。 ${}表示拼接sql串，通过${}可以将parameterType 传入的内容拼接在sql中且不进行jdbc类型转换， ${}可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。值得注意的是 该方式不能有效的防止sql注入 parameterType和resultType parameterType：指定输入参数类型，mybatis通过ognl从输入对象中获取参数值拼接在sql中。 resultType：指定输出结果类型，mybatis将sql查询结果的一行记录数据映射为resultType指定类型的对象。如果有多条数据，则分别进行映射，并把对象放到容器List中 selectOne和selectList selectOne查询一条记录，如果使用selectOne查询多条记录则抛出异常 org.apache.ibatis.exceptions.TooManyResultsException selectList可以查询一条或多条记录。 Mysql自增主键返回 在新增记录的时候在sql语句之前配置主键自增 1234567&lt;!-- order：设置在执行insert语句前执行查询id的sql，还指在执行insert语句之后执行查询id的sql --&gt;&lt;!-- resultType：设置返回的id的类型 --&gt;&lt;selectKey keyColumn=\"id\" keyProperty=\"id\" order=\"AFTER\" resultType=\"int\"&gt; SELECT LAST_INSERT_ID()&lt;/selectKey&gt; uuid实现主键 123&lt;selectKey keyColumn=\"id\" keyProperty=\"id\" order=\"BEFORE\" resultType=\"string\"&gt; SELECT LAST_INSERT_ID()&lt;/selectKey&gt; SqlSession的使用范围了解SqlSession的使用范围,首先要明白他是怎么创建的 SqlSession中封装了对数据库的操作，如：查询、插入、更新、删除等。 SqlSession通过SqlSessionFactory创建。 SqlSessionFactory是通过SqlSessionFactoryBuilder进行创建。 1.SqlSessionFactoryBuilder SqlSessionFactoryBuilder用于创建SqlSessionFacoty， SqlSessionFacoty一旦创建完成就不需要SqlSessionFactoryBuilder了， 因为SqlSession是通过SqlSessionFactory创建的。 所以可以将SqlSessionFactoryBuilder当成一个工具类使用， 最佳使用范围是方法范围即方法体内局部变量。 2.SqlSessionFactory SqlSessionFactory是一个接口，接口中定义了openSession的不同重载方法， SqlSessionFactory的最佳使用范围是整个应用运行期间，一旦创建后可以重复使用， 通常以单例模式管理SqlSessionFactory。 3.SqlSession SqlSession是一个面向用户的接口，sqlSession中定义了数据库操作方法。 每个线程都应该有它自己的SqlSession实例。 SqlSession的实例不能共享使用，它也是线程不安全的。 因此最佳的范围是请求或方法范围。 绝对不能将SqlSession实例的引用放在一个类的静态字段或实例字段中。 打开一个 SqlSession；使用完毕就要关闭它。 Mapper动态代理方式Mapper接口开发方法只需要程序员编写Mapper接口（相当于Dao接口），由Mybatis框架根据接口定义创建接口的动态代理对象，代理对象的方法体同上边Dao接口实现类方法。 Mapper接口开发需要遵循以下规范：Mapper.xml文件中的namespace与mapper接口的类路径相同。 Mapper接口方法名和Mapper.xml中定义的每个statement的id相同 Mapper接口方法的输入参数类型和mapper.xml中定义的每个sql 的parameterType的类型相同 Mapper接口方法的输出参数类型和mapper.xml中定义的每个sql的resultType的类型相同 Mapper.xml(映射文件)的配置12345&lt;mapper namespace=\"Mapper接口类路径\"&gt; &lt;select id=\"Mapper接口方法名\" parameterType=\"接口方法参数类型\" resultType=\"接口方法返回值类型\"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 注意:要在Mabits核心配置文件中配置加载映射文件(Mapper.xml) SqlMapConfig.xml配置文件的其他配置properties（属性）1234567&lt;!-- 使用resource属性加载外部配置文件 --&gt;&lt;properties resource=\"db.properties\"&gt; &lt;!-- 在properties内部用property定义属性 --&gt; &lt;!-- 如果外部配置文件有该属性，则内部定义属性被外部属性覆盖 --&gt; &lt;property name=\"jdbc.username\" value=\"root123\" /&gt; &lt;property name=\"jdbc.password\" value=\"root123\" /&gt;&lt;/properties&gt; typeAliases（类型别名）在Mybatis中有一些默认的别名,例如返回值类型的配置的时候,直接写类型名即可,不需要写类型的全限定名,这就是因为在Mybatis中已经配置好了一些默认的类型别名,直接使用即可,除此之外,还可以自定义类型别名: 在SqlMapConfig.xml中配置如下： 1234567&lt;typeAliases&gt; &lt;!-- 单个别名定义 --&gt; &lt;typeAlias alias=\"user\" type=\"User类的全限定名\" /&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（大小写不敏感） --&gt; &lt;package name=\"包扫描路径\" /&gt; &lt;package name=\"其它包\" /&gt;&lt;/typeAliases&gt; 需要注意的是,别名的大小写不敏感 mappers（映射器）Mapper配置的几种方法： 方式一: 12&lt;mapper resource=\" \" /&gt;&lt;!--使用相对于类路径的资源--&gt; 方式二: 12&lt;mapper class=\" \" /&gt;&lt;!--使用mapper接口类路径--&gt; 方式三:12&lt;package name=\"\"/&gt;&lt;!--注册指定包下的所有mapper接口--&gt; 注意: 使用方法二三时,要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中 动态sql通过mybatis提供的各种标签方法实现动态拼接sql 举例:需求是:根据姓名和性别查询用户,有可能是姓名性别都没选中,有可能只有一个姓名或只有一个性别,或两个条件都有 if标签的使用通过使用if标签可以实现判断各种查询情景 12345678910&lt;select id=\"queryUserByWhere\" parameterType=\"user\" resultType=\"user\"&gt; SELECT id, username, birthday, sex, address FROM `user` WHERE 1=1 &lt;if test=\"sex != null and sex != ''\"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username LIKE '%$&#123;username&#125;%' &lt;/if&gt;&lt;/select&gt; where标签的使用通过where标签可以对上面代码进行改造,将不用再写where和1=1的条件 123456789101112&lt;select id=\"queryUserByWhere\" parameterType=\"user\" resultType=\"user\"&gt; SELECT id, username, birthday, sex, address FROM `user`&lt;!-- where标签可以自动添加where，同时处理sql语句中第一个and关键字 --&gt; &lt;where&gt; &lt;if test=\"sex != null\"&gt; AND sex = #&#123;sex&#125; &lt;/if&gt; &lt;if test=\"username != null and username != ''\"&gt; AND username LIKE '%$&#123;username&#125;%' &lt;/if&gt; &lt;/where&gt;&lt;/select&gt; sql片段通过sql标签可以实现将重复性的条件提取出来直接在sql中引入即可(include) 12345&lt;!-- 声明sql片段 --&gt;&lt;sql id=\"userFields\"&gt; id, username, birthday, sex, address&lt;/sql&gt;SELECT &lt;include refid=\"userFields\" /&gt; FROM `user` foreach标签123456789101112131415&lt;select id=\"queryUserByIds\" parameterType=\"queryVo\" resultType=\"user\"&gt; SELECT * FROM `user` &lt;where&gt; &lt;!-- foreach标签，进行遍历 --&gt; &lt;!-- collection：遍历的集合，这里是QueryVo的ids属性 --&gt; &lt;!-- item：遍历的项目，可以随便写，，但是和后面的#&#123;&#125;里面要一致 --&gt; &lt;!-- open：在前面添加的sql片段 --&gt; &lt;!-- close：在结尾处添加的sql片段 --&gt; &lt;!-- separator：指定遍历的元素之间使用的分隔符 --&gt; &lt;foreach collection=\"ids\" item=\"item\" open=\"id IN (\" close=\")\" separator=\",\"&gt; #&#123;item&#125; &lt;/foreach&gt; &lt;/where&gt;&lt;/select&gt; 关联查询:一对一查询:需求：查询所有订单信息，关联查询下单用户信息 方式一: 使用resultType 改造订单pojo类，此pojo类中包括了订单信息和用户信息这样返回对象的时候，mybatis自动把用户信息也注入进来了 方式二:使用resultMap 定义专门的resultMap用于映射一对一查询结果。 Mapper.xml配置如下:1234567891011121314151617&lt;resultMap type=\"order\" id=\"orderUserResultMap\"&gt; &lt;id property=\"id\" column=\"id\" /&gt; &lt;result property=\"userId\" column=\"user_id\" /&gt; &lt;result property=\"number\" column=\"number\" /&gt; &lt;result property=\"createtime\" column=\"createtime\" /&gt; &lt;result property=\"note\" column=\"note\" /&gt; &lt;!-- association ：配置一对一属性 --&gt; &lt;!-- property:order里面的User属性名 --&gt; &lt;!-- javaType:属性类型 --&gt; &lt;association property=\"user\" javaType=\"user\"&gt; &lt;!-- id:声明主键，表示user_id是关联查询对象的唯一标识--&gt; &lt;id property=\"id\" column=\"user_id\" /&gt; &lt;result property=\"username\" column=\"username\" /&gt; &lt;result property=\"address\" column=\"address\" /&gt; &lt;/association&gt;&lt;/resultMap&gt; 一对多查询:需求:查询所有用户信息及用户关联的订单信息 查询方法:第一步,实体类中配置一对多关系属性 第二步,编写Mapper.xml 1234567891011121314151617181920&lt;resultMap type=\"user\" id=\"userOrderResultMap\"&gt; &lt;id property=\"id\" column=\"id\" /&gt; &lt;result property=\"username\" column=\"username\" /&gt; &lt;result property=\"birthday\" column=\"birthday\" /&gt; &lt;result property=\"sex\" column=\"sex\" /&gt; &lt;result property=\"address\" column=\"address\" /&gt; &lt;!-- 配置一对多的关系 --&gt; &lt;collection property=\"orders\" javaType=\"list\" ofType=\"order\"&gt; &lt;!-- 配置主键，是关联Order的唯一标识 --&gt; &lt;id property=\"id\" column=\"id\" /&gt; &lt;result property=\"number\" column=\"number\" /&gt; &lt;result property=\"createtime\" column=\"createtime\" /&gt; &lt;result property=\"note\" column=\"note\" /&gt; &lt;/collection&gt;&lt;/resultMap&gt; &lt;!--配置查询--&gt;&lt;select id=\"queryUserOrder\" resultMap=\"userOrderResultMap\"&gt; SELECT * FROM `user` u LEFT JOIN `order` o ON u.id = o.user_id&lt;/select&gt; 第三步,在UserMapper接口中定义查询方法 第四步,测试","tags":[{"name":"SSM","slug":"SSM","permalink":"http://ellisl.club/tags/SSM/"}]},{"title":"Hibernate","date":"2018-04-28T05:25:41.000Z","path":"/posts/25673/","text":"Hibernate 小结Hibernate简介:Hibernate是一个开放源码的对象关系映射框架,他对JDBC进行了轻量级的对象封装它将实体类和数据库建立映射关系,是一个全自动的ORM框架,是java持久层框架之一 Hibernate的优势:1.对JDBC进行了轻量级的对象封装,简化了DAO层繁琐的重复性代码,减少了内存消耗,加快了运行效率 2.Hibernate是一个基于JDBC的主流持久化框架，是一个优秀的ORM实现，简化了DAO层编码工作 3.Hibernate支持很多关系型数据库 4.开放源码,可扩展性强 ORM:对象关系映射:就是实体类和数据库表建立对应关系 通过Hibernate映射文件和Hibernate的核心配置文件实现 操作对象就相当于操作数据库表 执行原理: 1.get()在程序运行期间利用反射技术动态创建对象 2.根据hbm配置文件调用set方法进行绑定一一映射 实体类:1.实现序列化接口 2.私有化成员变量 3.提供无参构造(Hibernate反射创建对象用) 4.提供set/get方法 持久态对象的三种状态:1.瞬时态:不存在持久化标识OID 尚未与Hibernate Session关联对象,数据库中没有相应记录 2.持久态:存在持久化标识OID,与当前session有关联,并且关联的session没有关闭,数据库中有相应记录 3.托管态:存在持久化标识OID,与当前session没有关联,在数据库中有相应记录 Hibernate的一级缓存和二级缓存Hibernate向一级缓存存放数据时(保存在session中),同时保存快照数据(快照数据不可操作),当修改一级缓存中的数据进行flush操作时,会将session的数据和快照中的数据进行对比,若不一致,则会将session一级缓存中的数据更新到数据库中,同时更新快照区 get和load的区别:get如果没有找到会返回null,load如果没有找到会抛出异常 get会先查一级缓存,再查二级缓存,然后再查数据库 load会先查一级缓存,如果没找到就创建代理对象,等需要的时候去查询二级缓存和数据库(延迟加载) SessionFactory:SessionFactory是一个用于创建Session对象的工厂,是线程安全的,所以多个线程可以同时使用一个 SessionFactory.同时它里面还包含着对象关系映射有关的所以元数据,他是不可变的,一旦创建好就不能进行修改","tags":[{"name":"ssh","slug":"ssh","permalink":"http://ellisl.club/tags/ssh/"}]},{"title":"从前慢","date":"2018-04-28T05:06:24.000Z","path":"/posts/24768/","text":"从前慢 记得早先少年时 大家诚诚恳恳 说一句 是一句 清早上火车站 长街黑暗无行人 卖豆浆的小店冒着热气 从前的日色变得慢 车，马，邮件都慢 一生只够爱一个人 从前的锁也好看 钥匙精美有样子 你锁了 人家就懂了—木心","tags":[{"name":"poem","slug":"poem","permalink":"http://ellisl.club/tags/poem/"}]}]